<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/components/coreGrid.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/noderaider/gridiron" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-gridiron">gridiron</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-coreGrid">coreGrid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-drillGrid">drillGrid</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/components/coreGrid.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { CoreGrid as Core } from &apos;gridiron-core&apos;
import solvent from &apos;solvent&apos;
import expander from &apos;./expander&apos;
import classNames from &apos;classnames&apos;
import util from &apos;util&apos;
const should = require(&apos;chai&apos;).should()
const IS_BROWSER = typeof window === &apos;object&apos;

const resolver = solvent( { React: &apos;object&apos;
                          , connect: &apos;function&apos;
                          , AutoSizer: &apos;function&apos;
                          , Grid: &apos;function&apos;
                          , Immutable: &apos;object&apos;
                          } )
export default function coreGrid (deps, defaults = {}) {
  const { React, connect, AutoSizer, Grid, Immutable } = resolver(deps)
  const { Component, PropTypes, cloneElement } = React
  const { getState } = defaults
  should.exist(React)
  should.exist(connect)
  const Expander = expander({ React })

  const wideStyle = { display: &apos;flex&apos;
                    , flexDirection: &apos;row&apos;
                    , flex: &apos;1 0 auto&apos;
                    , justifyContent: &apos;space-between&apos;
                    , alignItems: &apos;center&apos;
                    , margin: &apos;auto&apos;
                    , padding: 5
                    }

  class CoreGrid extends Component {
    static propTypes = Core.PropTypes(React);
    static defaultProps = Core.DefaultProps(React);

    constructor(props) {
      super(props)
      this.state =  {}
    }
    render() {
      const { cols, rows, maxHeight, style, styles, theme, gridStyle, maxWidth, header, footer, pager } = this.props
      const spannedRows = rows.reduce((spanned, x, i) =&gt; {
        if(x.span === true)
          return [ ...spanned, i ]
        return spanned
      }, [])
      should.exist(cols)
      should.exist(rows)
      cols.should.be.instanceof(Array)
      rows.should.be.instanceof(Array)
      const colCount = cols.length
      const getRowCount = ({ rows = rows /*= mapRows(state)*/ } = {}) =&gt; (rows.size || rows.length) // 2 more than index for header and footer

      const resolveColWidth = (calculated, { minWidth, maxWidth } = {}) =&gt; {
        //console.debug(&apos;RESOLVE COL WIDTH&apos;, calculated, minWidth, maxWidth)
        if(minWidth &amp;&amp; calculated &lt; minWidth) {
          //console.debug(&apos;OVERRIDING CALCULATED WIDTH FOR MIN&apos;, calculated, minWidth)
          return minWidth
        }
        if(maxWidth &amp;&amp; calculated &gt; maxWidth) {
          //console.debug(&apos;OVERRIDING CALCULATED WIDTH FOR MAX&apos;, calculated, maxWidth)
          return maxWidth
        }
        return calculated
      }


      const containerClass = classNames(styles.container, theme.container)
      const innerContainerClass = classNames(styles.innerContainer, theme.innerContainer)
      const gridClass = classNames(styles.BodyGrid, theme.BodyGrid)

      const renderGrid = ({ preHeader, postHeader } = {}) =&gt; (
        &lt;div className={containerClass} style={style}&gt;
          &lt;div className={innerContainerClass}&gt;
            &lt;AutoSizer onResize={({ height, width }) =&gt; {
              this.setState({ height, width })
            }}&gt;

              {dimensions =&gt; {
                const width = this.state.width || dimensions.width
                const height = this.state.height || dimensions.height || 100
                let fixedWidthIndices = []
                const fixedCols = cols.filter((x, i) =&gt; {
                  const isFixed = x.width &amp;&amp; typeof x.width === &apos;number&apos;
                  if(isFixed) fixedWidthIndices.push(i)
                  return isFixed
                })

                const fixedWidth = fixedCols.reduce((sum, x) =&gt; sum += x.width, 0)
                const variableWidth = width - fixedWidth
                const variableColCount = cols.length - fixedCols.length
                const colWidths = cols.reduce((widthMap, x) =&gt; ({ ...widthMap, [x.id]: resolveColWidth(x.width ? x.width : variableWidth / variableColCount, x) }), {})
                const rowCount = getRowCount({ rows })
                return (
                  &lt;Grid
                    ref={x =&gt; this.grid = x}
                    className={gridClass}
                    style={gridStyle}
                    width={this.props.maxWidth || this.state.width || dimensions.width}
                    height={this.state.height || dimensions.height || 100}
                    columnCount={colCount}
                    rowCount={rowCount}
                    columnWidth={

                      ({ index }) =&gt; {
                        const col = cols[index]
                        return colWidths[col.id]
                      }
                    }
                    rowHeight={1}

                    cellRangeRenderer={
                      ({ cellCache, cellRenderer, columnSizeAndPositionManager, columnStartIndex, columnStopIndex, horizontalOffsetAdjustment, isScrolling, rowSizeAndPositionManager, rowStartIndex, rowStopIndex, scrollLeft, scrollTop, verticalOffsetAdjustment } = {}) =&gt; {
                        const renderedRows = []
                        const width = this.state.width || dimensions.width

                        /** GRID ROW HEADER */
                        if(header)
                          renderedRows.push(
                            &lt;div key=&quot;grid-header&quot; className={classNames(styles.headerGrid, theme.headerGrid)}&gt;
                              {preHeader ? preHeader : null}
                              {typeof header === &apos;function&apos; ? header() : header}
                              {postHeader ? postHeader : null}
                            &lt;/div&gt;
                          )

                        const gridRow = (rowKey, cells, { rowClass = &apos;Grid__row&apos;, rowStyle = {}, cellClass = &apos;Grid__cell&apos;, cellStyle = {} }) =&gt; {
                          should.exist(rowKey, &apos;rowKey is required&apos;)
                          return (
                            &lt;div key={rowKey} id={`${rowKey}-row`} className={styles.rowStyle} style={rowStyle}&gt;
                              {cells.map((x, i) =&gt; {
                                let computedStyle = typeof cellStyle === &apos;function&apos; ? cellStyle(i) : cellStyle
                                if(fixedWidthIndices.includes(i)) {
                                  const datum = columnSizeAndPositionManager.getSizeAndPositionOfCell(i)
                                  computedStyle = { ...computedStyle, flex: `0 1 ${datum.size}px` }
                                }
                                return (
                                  &lt;div
                                    key={`${rowKey}-${i}`}
                                    className={typeof cellClass === &apos;function&apos; ? cellClass(i) : cellClass}
                                    style={computedStyle}
                                  &gt;
                                    &lt;span className={classNames(styles.innerCell, theme.innerCell)}&gt;{x}&lt;/span&gt;
                                  &lt;/div&gt;
                              )
                              })
                            }
                            &lt;/div&gt;
                          )
                        }

                        /** COLUMN HEADERS */
                        renderedRows.push(gridRow(&apos;col-headers&apos;, cols.map(x =&gt; x.header({ rows, theme })), { rowClass: styles.rowStyle, cellClass: i =&gt; classNames(styles.headerCell, theme.headerCell, cols[i].className) }))

                        for (let rowIndex = rowStartIndex; rowIndex &lt;= rowStopIndex; rowIndex++) {
                          const renderedCells = []

                          if(spannedRows.includes(rowIndex)) {
                            const key = `${rowIndex}-span`
                            const child = (
                              &lt;div
                                key={key}
                                //style={wideStyle}
                                className={classNames(styles.Grid__span, theme.expanded, &apos;drill&apos;)}
                              &gt;
                                {rows[rowIndex].render()}
                              &lt;/div&gt;
                            )
                            renderedRows.push(child)
                          } else {
                            for (let columnIndex = columnStartIndex; columnIndex &lt;= columnStopIndex; columnIndex++) {
                              let columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex)

                              let key = `${rowIndex}-${columnIndex}`
                              let renderedCell

                              // Avoid re-creating cells while scrolling.
                              // This can lead to the same cell being created many times and can cause performance issues for &quot;heavy&quot; cells.
                              // If a scroll is in progress- cache and reuse cells.
                              // This cache will be thrown away once scrolling completes.
                              if (false) { //isScrolling) {
                                if (!cellCache[key]) {
                                  cellCache[key] = cellRenderer({ columnIndex
                                                                , isScrolling
                                                                , rowIndex
                                                                })
                                }
                                renderedCell = cellCache[key]
                              // If the user is no longer scrolling, don&apos;t cache cells.
                              // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.
                              } else {
                                renderedCell = cellRenderer({ columnIndex
                                                            , isScrolling
                                                            , rowIndex
                                                            })
                              }

                              if (renderedCell === null || renderedCell === false)
                                continue
                              renderedCells.push(renderedCell)
                            }
                          }
                          const cellClass = i =&gt; classNames(styles.cell, theme.cell, cols[i].className, rowIndex % 2 === 0 ? theme.evenRow : theme.oddRow)
                          renderedRows.push(gridRow(rowIndex, renderedCells, { rowClass: styles.rowStyle, cellClass }))
                        }

                        renderedRows.push(gridRow(&apos;col-footers&apos;, cols.map(x =&gt; x.footer ? x.footer({ rows, theme }) : null), { rowClass: styles.rowStyle, cellClass: i =&gt; classNames(styles.footerCell, theme.footerCell, cols[i].className) }))

                        if(footer) {
                          renderedRows.push(
                            &lt;div key=&quot;grid-footer&quot; style={wideStyle} className={classNames(styles.footerGrid, theme.footerGrid)}&gt;
                              {typeof footer === &apos;function&apos; ? footer() : footer}
                            &lt;/div&gt;)
                        }
                        return renderedRows
                      }
                    }

                    cellRenderer={
                      ({ columnIndex, rowIndex, isScrolling }) =&gt; {
                        const col = cols[columnIndex]
                        return rows[rowIndex].render()[columnIndex]
                      }
                    }
                  /&gt;
                )
              }}
            &lt;/AutoSizer&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )

      return renderGrid()
    }
    componentDidUpdate(prevProps, prevState) {
      if(prevState.width !== this.state.width || prevState.height !== this.state.height) {
        this.grid.recomputeGridSize()
      }
    }
  }
  return Core.Connect({ connect }, { getState })(CoreGrid)
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

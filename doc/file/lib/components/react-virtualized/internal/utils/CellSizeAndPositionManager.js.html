<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../../">
  <title data-ice="title">lib/components/react-virtualized/internal/utils/CellSizeAndPositionManager.js | redux-grid API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/cchamberlain/redux-grid" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createGrid">createGrid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createConnect">createConnect</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createMapDispatchToProps">createMapDispatchToProps</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createMapStateToProps">createMapStateToProps</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createPropTypes">createPropTypes</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/fixed-data-table</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createGrid">createGrid</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/react-virtualized/internal</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createExpandableCellRangeRenderer">createExpandableCellRangeRenderer</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/react-virtualized/internal/utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/components/react-virtualized/internal/utils/CellSizeAndPositionManager.js~CellSizeAndPositionManager.html">CellSizeAndPositionManager</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">helpers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/helpers/FakeObjectDataListStore.js~FakeObjectDataListStore.html">FakeObjectDataListStore</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/components/react-virtualized/internal/utils/CellSizeAndPositionManager.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Just-in-time calculates and caches size and position information for a collection of cells.
 */
export default class CellSizeAndPositionManager {
  constructor({ cellCount
              , cellSizeGetter
              , estimatedCellSize
              }) {
    this._cellSizeGetter = cellSizeGetter
    this._cellCount = cellCount
    this._estimatedCellSize = estimatedCellSize

    // Cache of size and position data for cells, mapped by cell index.
    // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex
    this._cellSizeAndPositionData = {}

    // Measurements for cells up to this index can be trusted; cells afterward should be estimated.
    this._lastMeasuredIndex = -1
  }

  configure = ( { cellCount
                , estimatedCellSize
                } ) =&gt; {
    this._cellCount = cellCount
    this._estimatedCellSize = estimatedCellSize
  };
  getCellCount = () =&gt; this._cellCount;
  getEstimatedCellSize = () =&gt; this._estimatedCellSize;
  getLastMeasuredIndex = () =&gt; this._lastMeasuredIndex;

  /**
   * This method returns the size and position for the cell at the specified index.
   * It just-in-time calculates (or used cached values) for cells leading up to the index.
   */
  getSizeAndPositionOfCell = index =&gt; {
    if (index &lt; 0 || index &gt;= this._cellCount)
      throw Error(`Requested index ${index} is outside of range 0..${this._cellCount}`)

    if (index &gt; this._lastMeasuredIndex) {
      let lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell()
      let offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size

      for (var i = this._lastMeasuredIndex + 1; i &lt;= index; i++) {
        let size = this._cellSizeGetter({ index: i })

        if (size == null || isNaN(size)) {
          throw Error(`Invalid size returned for cell ${i} of value ${size}`)
        }

        this._cellSizeAndPositionData[i] = {
          offset,
          size
        }

        offset += size
      }

      this._lastMeasuredIndex = index
    }

    return this._cellSizeAndPositionData[index]
  };

  getSizeAndPositionOfLastMeasuredCell = () =&gt; {
    return this._lastMeasuredIndex &gt;= 0
      ? this._cellSizeAndPositionData[this._lastMeasuredIndex]
      : {
        offset: 0,
        size: 0
      }
  };

  /**
   * Total size of all cells being measured.
   * This value will be completedly estimated initially.
   * As cells as measured the estimate will be updated.
   */
  getTotalSize = () =&gt; {
    const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell()
    return lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size + (this._cellCount - this._lastMeasuredIndex - 1) * this._estimatedCellSize
  };

  /**
   * Determines a new offset that ensures a certain cell is visible, given the current offset.
   * If the cell is already visible then the current offset will be returned.
   * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
   *
   * @param align Desired alignment within container; one of &quot;auto&quot; (default), &quot;start&quot;, or &quot;end&quot;
   * @param containerSize Total size (width or height) of the container
   * @param currentOffset Container&apos;s current (x or y) offset
   * @return Offset to use to ensure the specified cell is visible
   */
  getUpdatedOffsetForIndex = ({ align = &apos;auto&apos;
                              , containerSize
                              , currentOffset
                              , targetIndex
                              }) =&gt; {
    const datum = this.getSizeAndPositionOfCell(targetIndex)
    const maxOffset = datum.offset
    const minOffset = maxOffset - containerSize + datum.size

    switch (align) {
      case &apos;start&apos;:
        return maxOffset
      case &apos;end&apos;:
        return minOffset
      case &apos;center&apos;:
        return maxOffset - (containerSize + datum.size) / 2
      default:
        return Math.max(minOffset, Math.min(maxOffset, currentOffset))
    }
  };

  getVisibleCellRange = ( { containerSize
                          , offset
                          } ) =&gt; {
    const totalSize = this.getTotalSize()

    if (totalSize === 0) {
      return {}
    }

    const maxOffset = offset + containerSize
    const start = this._findNearestCell(offset)

    const datum = this.getSizeAndPositionOfCell(start)
    offset = datum.offset + datum.size

    let stop = start

    while (offset &lt; maxOffset &amp;&amp; stop &lt; this._cellCount - 1) {
      stop++

      offset += this.getSizeAndPositionOfCell(stop).size
    }

    return {
      start,
      stop
    }
  };

  /**
   * Clear all cached values for cells after the specified index.
   * This method should be called for any cell that has changed its size.
   * It will not immediately perform any calculations; they&apos;ll be performed the next time getSizeAndPositionOfCell() is called.
   */
  resetCell = index =&gt; this._lastMeasuredIndex = index - 1;

  _binarySearch = ( { high
                    , low
                    , offset
                    }) =&gt; {
    let middle
    let currentOffset

    while (low &lt;= high) {
      middle = low + Math.floor((high - low) / 2)
      currentOffset = this.getSizeAndPositionOfCell(middle).offset

      if (currentOffset === offset)
        return middle
      else if (currentOffset &lt; offset)
        low = middle + 1
      else if (currentOffset &gt; offset)
        high = middle - 1
    }

    if (low &gt; 0)
      return low - 1
  };

  _exponentialSearch = ({ index
                        , offset
                        }) =&gt; {
    let interval = 1

    while (
      index &lt; this._cellCount &amp;&amp;
      this.getSizeAndPositionOfCell(index).offset &lt; offset
    ) {
      index += interval
      interval *= 2
    }

    return this._binarySearch({
      high: Math.min(index, this._cellCount - 1),
      low: Math.floor(index / 2),
      offset
    })
  };

  /**
   * Searches for the cell (index) nearest the specified offset.
   *
   * If no exact match is found the next lowest cell index will be returned.
   * This allows partially visible cells (with offsets just before/above the fold) to be visible.
   */
  _findNearestCell = offset =&gt; {
    if (isNaN(offset))
      throw Error(`Invalid offset ${offset} specified`)

    // Our search algorithms find the nearest match at or below the specified offset.
    // So make sure the offset is at least 0 or no match will be found.
    offset = Math.max(0, offset)

    const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell()
    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex)

    if (lastMeasuredCellSizeAndPosition.offset &gt;= offset) {
      // If we&apos;ve already measured cells within this range just use a binary search as it&apos;s faster.
      return this._binarySearch({
        high: lastMeasuredIndex,
        low: 0,
        offset
      })
    } else {
      // If we haven&apos;t yet measured this high, fallback to an exponential search with an inner binary search.
      // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.
      // The overall complexity for this approach is O(log n).
      return this._exponentialSearch({
        index: lastMeasuredIndex,
        offset
      })
    }
  };
}

/*
type CellSizeAndPositionManagerConstructorParams = {
  cellCount: number,
  cellSizeGetter: Function,
  estimatedCellSize: number
};

type ConfigureParams = {
  cellCount: number,
  estimatedCellSize: number
};

type GetVisibleCellRangeParams = {
  containerSize: number,
  offset: number
};

type SizeAndPositionData = {
  offset: number,
  size: number
};

type VisibleCellRange = {
  start: ?number,
  stop: ?number
};
*/
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
